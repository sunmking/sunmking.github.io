<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>千字文</title>
      <link href="/2023/02/24/qian-zi-wen/"/>
      <url>/2023/02/24/qian-zi-wen/</url>
      
        <content type="html"><![CDATA[<center><p>天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。</p><p>寒来暑往，秋收冬藏。闰余成岁，律吕调阳。</p><p>云腾致雨，露结为霜。金生丽水，玉出昆冈。</p><p>剑号巨阙，珠称夜光。果珍李柰，菜重芥姜。</p><p>海咸河淡，鳞潜羽翔。龙师火帝，鸟官人皇。</p><p>始制文字，乃服衣裳。推位让国，有虞陶唐。</p><p>吊民伐罪，周发殷汤。坐朝问道，垂拱平章。</p><p>爱育黎首，臣伏戎羌。遐迩一体，率宾归王。</p><p>鸣凤在竹，白驹食场。化被草木，赖及万方。</p><p>盖此身发，四大五常。恭惟鞠养，岂敢毁伤。</p><p>女慕贞洁，男效才良。知过必改，得能莫忘。</p><p>罔谈彼短，靡恃己长。信使可覆，器欲难量。</p><p>墨悲丝染，诗赞羔羊。景行维贤，克念作圣。</p><p>德建名立，形端表正。空谷传声，虚堂习听。</p><p>祸因恶积，福缘善庆。尺璧非宝，寸阴是竞。</p><p>资父事君，曰严与敬。孝当竭力，忠则尽命。</p><p>临深履薄，夙兴温凊。似兰斯馨，如松之盛。</p><p>川流不息，渊澄取映。容止若思，言辞安定。</p><p>笃初诚美，慎终宜令。荣业所基，籍甚无竟。</p><p>学优登仕，摄职从政。存以甘棠，去而益咏。</p><p>乐殊贵贱，礼别尊卑。上和下睦，夫唱妇随。</p><p>外受傅训，入奉母仪。诸姑伯叔，犹子比儿。</p><p>孔怀兄弟，同气连枝。交友投分，切磨箴规。</p><p>仁慈隐恻，造次弗离。节义廉退，颠沛匪亏。</p><p>性静情逸，心动神疲。守真志满，逐物意移。</p><p>坚持雅操，好爵自縻。都邑华夏，东西二京。</p><p>背邙面洛，浮渭据泾。宫殿盘郁，楼观飞惊。</p><p>图写禽兽，画彩仙灵。丙舍旁启，甲帐对楹。</p><p>肆筵设席，鼓瑟吹笙。升阶纳陛，弁转疑星。</p><p>右通广内，左达承明。既集坟典，亦聚群英。</p><p>杜稿钟隶，漆书壁经。</p><p>府罗将相，路侠槐卿。户封八县，家给千兵。</p><p>高冠陪辇，驱毂振缨。世禄侈富，车驾肥轻。</p><p>策功茂实，勒碑刻铭。磻溪伊尹，佐时阿衡。</p><p>奄宅曲阜，微旦孰营。桓公匡合，济弱扶倾。</p><p>绮回汉惠，说感武丁。俊义密勿，多士实宁。</p><p>晋楚更霸，赵魏困横。假途灭虢，践土会盟。</p><p>何遵约法，韩弊烦刑。起翦颇牧，用军最精。</p><p>宣威沙漠，驰誉丹青。九州禹迹，百郡秦并。</p><p>岳宗泰岱，禅主云亭。雁门紫塞，鸡田赤城。</p><p>昆池碣石，钜野洞庭。旷远绵邈，岩岫杳冥。</p><p>治本于农，务兹稼穑。俶载南亩，我艺黍稷。</p><p>税熟贡新，劝赏黜陟。孟轲敦素，史鱼秉直。</p><p>庶几中庸，劳谦谨敕。聆音察理，鉴貌辨色。</p><p>贻厥嘉猷，勉其祗植。省躬讥诫，宠增抗极。</p><p>殆辱近耻，林皋幸即。两疏见机，解组谁逼。</p><p>索居闲处，沉默寂寥。求古寻论，散虑逍遥。</p><p>欣奏累遣，戚谢欢招。渠荷的历，园莽抽条。</p><p>枇杷晚翠，梧桐蚤凋。陈根委翳，落叶飘摇。</p><p>游鹍独运，凌摩绛霄。耽读玩市，寓目囊箱。</p><p>易輶攸畏，属耳垣墙。具膳餐饭，适口充肠。</p><p>饱饫烹宰，饥厌糟糠。亲戚故旧，老少异粮。</p><p>妾御绩纺，侍巾帷房。纨扇圆洁，银烛炜煌。</p><p>昼眠夕寐，蓝笋象床。弦歌酒宴，接杯举觞。</p><p>矫手顿足，悦豫且康。嫡后嗣续，祭祀烝尝。</p><p>稽颡再拜，悚惧恐惶。笺牒简要，顾答审详。</p><p>骸垢想浴，执热愿凉。驴骡犊特，骇跃超骧。</p><p>诛斩贼盗，捕获叛亡。布射僚丸，嵇琴阮啸。</p><p>恬笔伦纸，钧巧任钓。释纷利俗，并皆佳妙。</p><p>毛施淑姿，工颦妍笑。年矢每催，曦晖朗曜。</p><p>璇玑悬斡，晦魄环照。指薪修祜，永绥吉劭。</p><p>矩步引领，俯仰廊庙。束带矜庄，徘徊瞻眺。</p><p>孤陋寡闻，愚蒙等诮。谓语助者，焉哉乎也。</p></center>]]></content>
      
      
      <categories>
          
          <category> 经典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 千字文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker PHP 入门实践(四)</title>
      <link href="/2023/02/24/docker-php-ru-men-shi-jian-si/"/>
      <url>/2023/02/24/docker-php-ru-men-shi-jian-si/</url>
      
        <content type="html"><![CDATA[<p><a name="bad4c417"></a></p><h1 id="第4章-连接到数据库"><a href="#第4章-连接到数据库" class="headerlink" title="第4章. 连接到数据库"></a>第4章. 连接到数据库</h1><p>在连接数据库之前，我们需要确保我们的PHP容器已安装所有必要的扩展。默认情况下，Docker Hub 上的 PHP 镜像都是非常轻量级的，因此它不包含您可能需要的许多PHP扩展或Linux包。您必须根据项目优先级在较小或者更灵活的镜像之间进行权衡，但是我们知道该项目需要用到MySQL，因此让我们在 PHP 镜像中安装所需的拓展吧</p><blockquote><p>使用基础的 PHP 镜像通常是一个很好的起点，但是我也可以在 Github 中查找使用启用常见扩展的 PHP 镜像。查看<a href="https://github.com/shiphp/dockerfiles">此存储库了解更多信息</a>。</p></blockquote><p><a name="1bff6d8a"></a></p><h2 id="创建自定义Dockerfile"><a href="#创建自定义Dockerfile" class="headerlink" title="创建自定义Dockerfile"></a>创建自定义Dockerfile</h2><p>进入到我们的<code>天气应用</code>项目的根目录，创建一个的新文件命名为<code>Dockerfile</code>。Dockerfile没有扩展名，用于配置和设置 Docker 镜像。<a href="https://hub.docker.com/">Docker Hub</a> 上的所有镜像都有有相应的 Dockerfile 文件，通常您可以在 GitHub 上找到它们。<a href="https://github.com/docker-library/php">PHP的dockerfile在这里</a>，但它们可能会有点混乱，因为它们是相互关联的的。我们的 Dockerfile 会简单得多:</p><p><a name="Dockerfile"></a></p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><pre class="line-numbers language-none"><code class="language-none">FROM php:apacheRUN docker-php-source extract &amp;&amp; docker-php-ext-install mysqli pdo pdo_mysql &amp;&amp; docker-php-source delete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a name="1e1181cb"></a></p><h3 id="解疑小课堂"><a href="#解疑小课堂" class="headerlink" title="解疑小课堂"></a>解疑小课堂</h3><p>此 Dockerfile 有两行:</p><ul><li><code>FROM php:apache</code> - 这告诉 Docker 在开始构建时选择哪个镜像。你可以从一个Linux发行版开始 (比如<a href="https://hub.docker.com/_/ubuntu/">Ubuntu</a> 或者超轻 <a href="https://hub.docker.com/_/alpine/">alpine</a> )，或者您也可以自己构建一个相同的镜像。在这里，我们选择<code>php:apache</code>镜像作为我们的运行容器。</li><li><code>RUN docker-php-source extract...</code> - 这是添加我们需要的 PHP 扩展。在我们的例子中，我们只想使用 <a href="http://php.net/manual/en/book.mysqli.php">mysqli函数</a> 用于操作 Mysql 数据库。由于这是一个非常常见的扩展，当我们选用 PHP 基础镜像时，PHP镜像中有自动添加它的方法。</li></ul><blockquote><p>查看 <a href="https://docs.docker.com/engine/reference/builder/">官方Docker文档</a> 有关扩展现有镜像的更多配置命令。</p></blockquote><p><a name="82bc3425"></a></p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>我们需要通过刚刚创建的 Dockerfile 去构建我们所需的镜像:</p><pre class="line-numbers language-none"><code class="language-none">cd E:/workplace/docker-app/weather-appdocker build . -t sunmking/weather-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们运行此命令构建 Docker 镜像时，将看到以下输出，具体如下:</p><pre class="line-numbers language-none"><code class="language-none">[+] Building 0.3s (6/6) FINISHED =&gt; [internal] load build definition from Dockerfile                                                               0.1s =&gt; =&gt; transferring dockerfile: 31B                                                                                0.0s =&gt; [internal] load .dockerignore                                                                                  0.1s =&gt; =&gt; transferring context: 2B                                                                                    0.0s =&gt; [internal] load metadata for docker.io/library/php:apache                                                      0.0s =&gt; [1/2] FROM docker.io/library/php:apache                                                                        0.0s =&gt; CACHED [2/2] RUN docker-php-source extract &amp;&amp; docker-php-ext-install mysqli &amp;&amp; docker-php-source delete        0.0s =&gt; exporting to image                                                                                             0.1s =&gt; =&gt; exporting layers                                                                                            0.0s =&gt; =&gt; writing image sha256:d92e846df4b0210c29f84c8f5ec8affdb8a823b6de34a24ac460564f160e6207                       0.0s =&gt; =&gt; naming to docker.io/sunmking/weather-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="1e1181cb-1"></a></p><h3 id="解疑小课堂-1"><a href="#解疑小课堂-1" class="headerlink" title="解疑小课堂"></a>解疑小课堂</h3><p><a href="https://docs.docker.com/engine/reference/commandline/build/">Docker build</a>  通过刚刚创建的 Dockerfile 构建一个可用于运行容器的镜像。在该命令中，我们使了两个参数:</p><ul><li><code>.</code> - 点让Docker知道我们构建的 “content” – 在这种情况下，它是当前目录。您也可以使用绝对路径，如<code>/用户/用户名/天气-应用</code>如果您知道 Dockerfile 的确切路径。Docker会在包含Dockerfile的目录的上下文中自动构建此镜像，因此请确保 Dockerfile 位于项目的根目录。</li><li><code>-t sunmking/weather-app</code> - 的<code>-t</code>为您的镜像设置一个 “标签”。此标签可让您更轻松地从镜像中创建容器，或将镜像推送到镜像注册中心以与其他人共享。</li></ul><p>我们可以在本地计算机上运行  docker images 来查看所有的 Docker 镜像。当我们运行此命令时，可以在终端中看到如下内容:</p><pre class="line-numbers language-none"><code class="language-none">REPOSITORY                           TAG       IMAGE ID       CREATED         SIZEsunmking/weather-app                 latest    d92e846df4b0   2 hours ago     477MBdocker101tutorial                    latest    870f3cf07e24   4 days ago      28.9MBalpine/git                           latest    b80d2cac43e4   12 days ago     43.6MBsnyk/snyk-docker-desktop-extension   0.6.2     d070900ca2ee   6 weeks ago     71.5kBcomposer                             latest    c8d389ce4877   9 months ago    193MBphp                                  apache    b4e8e213b0ec   10 months ago   477MBphp                                  latest    13b9b1961ba3   10 months ago   484MBmysql                                5.7       c20987f18b13   10 months ago   448MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="7716a1d0"></a></p><h2 id="运行MySQL容器"><a href="#运行MySQL容器" class="headerlink" title="运行MySQL容器"></a>运行MySQL容器</h2><p>在介绍中，我提到Docker容器可以通过 <a href="https://docs.docker.com/engine/userguide/networking/">Docker的网络功能</a> 方式 “链接 “起来。为了让我们的 PHP 应用程序从数据库中获取数据，我们需要将其链接到可用的数据库容器。OK，让我们l来启动一个新的 MySQL 容器，以便我们可以将web应用程序链接到它:</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --rm --name weather-db -e MYSQL_USER=admin -e MYSQL_DATABASE=weather -e MYSQL_PASSWORD=wt2022@1019 -e MYSQL_RANDOM_ROOT_PASSWORD=true mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a name="1e1181cb-2"></a></p><h3 id="解疑小课堂-2"><a href="#解疑小课堂-2" class="headerlink" title="解疑小课堂"></a>解疑小课堂</h3><p>当我们运行上述 docker run 命令时，Docker 将拉取最新版本的 <a href="https://hub.docker.com/_/mysql/">MySQL 5.7镜像</a> 并启动名为weather-db的容器。跟我们运行 PHP 容器一样，MySQL <a href="https://hub.docker.com/_/mysql/">在 Docker Hub上有很多版本的 Docker 镜像</a> ,您可以以几乎相同的方式使用它们。上面的命令包含了一些新的参数，让我来给你们介绍一下:</p><ul><li><code>-d</code> - 这将在 “Detached” 模式下运行容器，这意味着您不用保持终端与容器连接，你可以直接关闭你的终端窗口，你的容器依旧在后台安稳的运行着。</li><li><code>--name weather-db</code> -命名我们的数据库容器很重要，因为你可以更加方便的通过名称去连接你创建的容器。我们也可以使用这个名称在我们的 PHP 应用程序中连接到 MySQL 数据库，我们将会在后面遇到。</li><li><code>-e MYSQL_USER=admin</code> - <a href="https://hub.docker.com/_/mysql/">MySQL镜像</a> 包括几个 -e (环境变量) 选项。第一个设置了我们将在PHP应用程序中使用的 MySQL 用户的用户名。有关环境选择的更多信息，请访问<a href="https://hub.docker.com/_/mysql/">Docker Hub官方镜像</a>。</li><li><code>-e MYSQL_DATABASE=weather</code> -默认情况下，容器不会创建数据库。虽然您可以通过登录容器来手动创建一个 (这将在下一节中介绍)，但是像这样预先创建数据库会更加简便。</li><li><code>-e MYSQL_PASSWORD=wt2022@1019</code> -这将设置数据库的初始密码。不管我们是不是在本地开发，都应该设置为强密码。</li><li><code>-e MYSQL_RANDOM_ROOT_PASSWORD=true</code> - 为 root  用户设置一个随机的密码，不管在什么情况下都不要登录 root 账户。</li><li><code>mysql:5.7</code> - 与 PHP 镜像一样，您可以选择要使用的MySQL版本。在这里，我选择使用版本5.7。</li></ul><p>就像<code>php:apache</code>镜像，默认的镜像就可以了，所以我们不需要在镜像中添加任何内容。</p><p><a name="73fa45fb"></a></p><h2 id="登录到正在运行的容器"><a href="#登录到正在运行的容器" class="headerlink" title="登录到正在运行的容器"></a>登录到正在运行的容器</h2><p>此时，我们想检查新容器中的数据库是否正常工作，但是如何访问正在运行的 Docker 容器呢？下面我们将使用<code>docker exec</code>命令进入新容器的终端，然后我们将使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html">MySQL命令行界面</a> 创建我们所需要的数据库或者数据表。</p><p>我们可以使用以下命令进入正在运行的数据库容器的 bash 终端:</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it weather-db bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你应该看到一条像<code>root@3cad1127aa0d:/#</code>(容器的ID) 在终端上，表示您现在已登录到正在运行的容器。从容器内 (不是本地主机上) 运行:</p><pre class="line-numbers language-none"><code class="language-none">$ mysql --user=admin --passwordEnter password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入您为上面创建的MySQL容器选择的密码 (在本例中为p23l % v11p)，然后点击 “返回” 键。您将看到一些关于MySQL的信息，如下所示:</p><pre class="line-numbers language-none"><code class="language-none">PS E:\workplace\docker-app\weather-app&gt; docker exec -it weather-db bashroot@4c9a8b9ebce0:/# mysql -u admin -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.36 MySQL Community Server (GPL)Copyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，让我们查看一下我们的数据库，是用<code>show databases;</code>命令:</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || weather            |+--------------------+2 rows in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="1e1181cb-3"></a></p><h3 id="解疑小课堂-3"><a href="#解疑小课堂-3" class="headerlink" title="解疑小课堂"></a>解疑小课堂</h3><p>在本章的的前面部分中，我们登录到正在运行的数据库容器上，然后通过命令行登录到 MySQL，并且查看了有哪些数据库。由于大家可能不熟悉这些命令，我将逐一介绍它们。</p><p><a name="17b7a417"></a></p><h4 id="Docker-Exec"><a href="#Docker-Exec" class="headerlink" title="Docker Exec"></a>Docker Exec</h4><ul><li><code>docker exec</code> - 这是<a href="https://docs.docker.com/engine/reference/commandline/exec/">用于执行 Docker 命令</a>是我们可以进入在正在运行的容器上。docker exec 还有有许多选项，这里我们就不一一介绍了，大家可以去官方文档中了解。</li><li><code>-it</code> - <code>-it</code>这两个标志通常是在一起使用的。i表示交互式的，表示[cmd]是一个有用户输入的程序，比如/bin/bash  和 python 等等。-t 产生一个终端。所以说有-i就必须有-t，不然怎么输入呢。这[cmd] 有的镜像是有默认值的，比如centos的镜像的默认值/bin/bash，而python镜像的默认值是python。所以说[cmd]是可以不写的。</li><li><code>weather-db</code> -这个是我们要在其上运行命令的正在运行的容器的名称 (您也可以使用容器 ID)。</li><li><code>bash</code> - 最后，这是我们要在容器中运行的命令。<a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a> 是大多数Linux发行版中安装的shell，允许我们在容器上运行其他程序。如果您的容器没有安装bash，您也可以尝试 <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/sh.html">sh</a>。</li></ul><p><a name="82a01bb1"></a></p><h4 id="MySQL-CLI"><a href="#MySQL-CLI" class="headerlink" title="MySQL CLI"></a>MySQL CLI</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html">MySQL CLI</a> 还提供了许多选项，以下是我们使用的三个选项:</p><ul><li><code>mysql</code> - 这是用于从终端访问MySQL的命令。如果您一直在VM或本地计算机上使用MySQL，则没有什么不同。</li><li><code>--user=admin</code> - 我们在此处指定用户名，以便 MySQL 知道我们希望以特定用户身份访问，而不是 <code>root</code>.</li><li><code>--password</code> -密码标志指示MySQL给我们密码提示。您也可以直接在命令中输入密码，但它通常不太安全。</li></ul><p><a name="e48a3d66"></a></p><h4 id="退出MySQL和容器"><a href="#退出MySQL和容器" class="headerlink" title="退出MySQL和容器"></a>退出MySQL和容器</h4><p>我们现在已经完成了MySQL容器，所以让我们退出并停止该容器:</p><ul><li>要退出MySQL CLI，请键入<code>\ q</code>然后按 “Enter”。</li><li>通过键入退出容器<code>exit</code>然后按 “Enter”。</li><li>通过键入<code>docker stop weather-db</code>来停止容器, 然后再次 “Enter”。</li></ul><p>完成后，整个命令行输出应如下所示:</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; \qByeroot@4c9a8b9ebce0:/# exitexitPS E:\workplace\docker-app\weather-app&gt; docker stop weather-dbweather-db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们现在已经解决了如何运行 MySQL 容器，并且我们可以登录访问数据库，但是我们将如何保存在容器中的数据？当我们停止这个容器时会发生什么？数据的持久性在现实世界的应用中是很重要的，所以在下一节中，我们将深入研究如何在我们的容器持久化保存我们的数据。</p><p><a name="8b0c167f"></a></p><h2 id="保存们数据库容器中的数据"><a href="#保存们数据库容器中的数据" class="headerlink" title="保存们数据库容器中的数据"></a>保存们数据库容器中的数据</h2><p>到目前为止，我们已经启动了数据库容器并自动创建了一个数据库和用户。这是很不错的开始，但是当我们把这个数据库连接到我们的 PHP 应用程序时，我们要确保数据库的表和值即使在我们的容器停止后也会被保存。否则，每次我们的数据库容器重新启动时，我们将不得不重建数据库和添加数据。</p><p>从容器中保存数据用于本地开发的最好方法是挂载一个数据卷。这对我们的 PHP 代码的本地开发是非常有效的，而我们挂载数据库数据卷的过程也非常相似。在我们启动 PHP 容器是也挂载了一个（在我们的例子中，我们之前创建的weather-app 目录），但你可以从本机系统的任何地方挂载卷，我这里把数据挂载在项目的同级目录 .data 中。</p><p>现在我们开始学 如何保存 mysql 容器里的数据, 现在进入到 <code>weather-app</code> 项目下执行以下命令:</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --rm --name weather-db -e MYSQL_USER=admin -e MYSQL_DATABASE=weather -e MYSQL_PASSWORD=wt2022@1019 -e MYSQL_RANDOM_ROOT_PASSWORD=true -v E:/workplace/docker-app/.data:/var/lib/mysql mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a name="1e1181cb-4"></a></p><h3 id="解疑小课堂-4"><a href="#解疑小课堂-4" class="headerlink" title="解疑小课堂"></a>解疑小课堂</h3><p>我们在这个docker运行命令中添加的唯一内容是 -v E:/workplace/docker-app/.data:/var/lib/mysql 。该命令是把一个卷从我们的本地目录挂载到 MySQL 容器中。当我们运行上面的命令时在（.data/）目录中会出现很多文件和目录。这些是MySQL用来存储数据的文件，你可以从你的终端查看这些文件。</p><pre class="line-numbers language-none"><code class="language-none">$ ls -a .data/ # Linux OR MAcor$ cd E:/workplace/docker-app/.data/ # win$ dir # win<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>显示输出如下:</p><pre class="line-numbers language-none"><code class="language-none"> 目录: E:\workplace\docker-app\.dataMode                 LastWriteTime         Length Name----                 -------------         ------ ----d-----        2022/10/19     11:09                mysqld-----        2022/10/19     11:09                performance_schemad-----        2022/10/19     11:09                sysd-----        2022/10/19     11:10                weather-a----        2022/10/19     11:09             56 auto.cnf-a----        2022/10/19     11:09           1676 ca-key.pem-a----        2022/10/19     11:09           1112 ca.pem-a----        2022/10/19     11:09           1112 client-cert.pem-a----        2022/10/19     11:09           1680 client-key.pem-a----        2022/10/19     14:36       79691776 ibdata1-a----        2022/10/19     14:36       12582912 ibtmp1-a----        2022/10/19     11:14            694 ib_buffer_pool-a----        2022/10/19     14:36       50331648 ib_logfile0-a----        2022/10/19     11:09       50331648 ib_logfile1-a----        2022/10/19     11:09           1680 private_key.pem-a----        2022/10/19     11:09            452 public_key.pem-a----        2022/10/19     11:09           1112 server-cert.pem-a----        2022/10/19     11:09           1676 server-key.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不要担心这些都是什么意思（尽管如果你有兴趣，你可以阅读一下<a href="https://dev.mysql.com/doc/internals/en/">MySQL的文档</a>）。在这，我们只关心在 MySQL 容器中使用来自我们主机的数据，允许我们在容器关闭后仍能保持数据库数据。<br><a name="1b33a3ab"></a></p><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p>由于这个应用程序需要缓存来自 高德天气 API 的结果，所以我们要创建一个 location 表，并添加列id、weather和last_updated。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/267928/1666162238589-21ae541b-1c94-4a73-adac-8bd93ee25de2.png#clientId=uebaa1df6-e0ae-4&amp;from=ui&amp;id=ufcc85641&amp;name=diagram3.png&amp;originHeight=335&amp;originWidth=890&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23528&amp;status=done&amp;style=none&amp;taskId=uec3e7c8a-098c-4913-b737-5e61a2fdb55&amp;title=" alt="diagram3.png"></p><p>如果MySQL容器没有运行，那么使用上面的方法启动它，挂载数据卷:</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --rm --name weather-db -e MYSQL_USER=admin -e MYSQL_DATABASE=weather -e MYSQL_PASSWORD=wt2022@1019 -e MYSQL_RANDOM_ROOT_PASSWORD=true -v E:/workplace/docker-app/.data:/var/lib/mysql mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登录到 Mysql 容器并进入到 MySQL CLI 中。这一次，我们将一步到位创建数据表:</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it weather-db mysql --user=admin --password='wt2022@1019' weather<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，运行 Mysql SQL 命令来创建我们上述的数据库表:</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; CREATE TABLE locations (id VARCHAR(64) NOT NULL, weather JSON NULL, last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应该会得到反馈 <code>Query OK</code>, 你也可以通过运行 <code>SHOW TABLES;</code>命令来查看创建的表. 然后输入 <code>\q</code>退出 mysql 终端.</p><p><a name="1e1181cb-5"></a></p><h3 id="解疑小课堂-5"><a href="#解疑小课堂-5" class="headerlink" title="解疑小课堂"></a>解疑小课堂</h3><p>与上次登录 MySQL 命令行不同的是，这次我们把这个过程缩减到只有一个步骤。记住，当运行 docker run或 docker exec 时，后面的参数部分是我们想在容器中运行的命令。这意味着我们不需要先登录到bash会话，再登录到MySQL，我们可以直接登录到 MySQL CLI。<br><a name="d27ea5c8"></a></p><h2 id="将-PHP-应用程序中的数据保存到数据库"><a href="#将-PHP-应用程序中的数据保存到数据库" class="headerlink" title="将 PHP 应用程序中的数据保存到数据库"></a>将 PHP 应用程序中的数据保存到数据库</h2><p>现在，我们的数据库已经准备好了，即使在容器被移除后，它也会保存这些数据，我们需要更新我们的PHP应用程序，以连接到数据库并存储天气结果。</p><p>最初，我们是直接从 高德天气 API获取数据，但现在我们已经有了一个存储机制（即：我们的数据库），让我们让应用程序将数据保存到数据库，以便减少 API 请求。</p><p>首先进入到项目的根目录 运行 cp .example.env .env 并编辑 .env 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">APP_DEBUG = true[APP]DEFAULT_TIMEZONE = Asia/Shanghai[DATABASE]TYPE = mysqlHOSTNAME = weather-dbDATABASE = weatherUSERNAME = adminPASSWORD = 'wt2022@1019'HOSTPORT = 3306CHARSET = utf8DEBUG = true[LANG]default_lang = zh-cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们开始修改我们的业务逻辑，打开项目根目录下的 app/controller/Weather.php 文件，更新如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpnamespace app\controller;use app\BaseController;use Clydecn\Amap\Weather as AmapWeather;use think\facade\Db;class Weather extends BaseController{    public $key;    public $weather;    // 初始化    protected function initialize()    {        $this-&gt;key = "xxxxxxxxxxxxxxxx"; // 高德 KEY        $this-&gt;weather = new AmapWeather($this-&gt;key);    }    public function get()    {        $rid = $this-&gt;request-&gt;param('location_id', '310000');        // 通过 Mysql 查询天气信息        $weather = Db::table('locations')-&gt;where(['id' =&gt; $rid])-&gt;find();        // 如果查询到了        if($weather){            //直接返回            return json(json_decode($weather['weather'],true),200);        }        // 通过 API 查询当天天气        $res = $this-&gt;weather-&gt;getLiveWeather($rid);        //将查询的结果插入数据库        Db::table('locations')-&gt;insert([            'id'=&gt;$rid,            'weather'=&gt;json_encode($res),            'last_updated'=&gt;date('Y-m-d H:i:s'),        ]);        return json($res, 200);    }    public function delete()    {        // todo        echo "location_id is " . $this-&gt;request-&gt;param('location_id');    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="1e1181cb-6"></a></p><h3 id="解疑小课堂-6"><a href="#解疑小课堂-6" class="headerlink" title="解疑小课堂"></a>解疑小课堂</h3><p>在这里我们做了两步操作：</p><ol><li>添加数据库配置</li></ol><blockquote><p>ThinkPHP 数据库配置，可以在 .env 里面配置，若果有不明白的可以查看 <a href="https://www.kancloud.cn/manual/thinkphp6_0">ThinkPHP6.0完全开发手册</a></p></blockquote><ol start="2"><li>添加业务逻辑<blockquote><ol><li>查询数据是否存在，存在就响应已经存在的数据</li><li>如果数据不存在，就直接请求接口并存储在数据库中，以待下次查询</li></ol></blockquote></li></ol><p>虽然代码中的注释可能会有帮助，但如果你不熟悉 ThinkPHP6，还是有一些细节值得关注的:</p><ul><li><code>$rid=$this-&gt;request-&gt;param('location_id', '310000');</code> - ThinkPHP6 中获取参数的方法.</li><li><code>$weather=Db::table('locations')-&gt;where(['id' =&gt; $rid])-&gt;find();</code> - 数据库查询.</li><li><code>returnjson(json_decode($weather['weather'],true),200);</code> - 将结果以 json 的格式展现给用户.</li></ul><p><a name="d8445313"></a></p><h2 id="连接-PHP-容器"><a href="#连接-PHP-容器" class="headerlink" title="连接 PHP 容器"></a>连接 PHP 容器</h2><p>有了代码，现在我们需要运行 PHP 容器，链接到我们刚刚启动的MySQL数据库容器:</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --privileged=true --rm --name=weather-app -p 38000:80 -v E:/workplace/docker-app/weather-app/:/var/www/html --link weather-db sunmking/weather-app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a name="1e1181cb-7"></a></p><h3 id="解疑课堂"><a href="#解疑课堂" class="headerlink" title="解疑课堂"></a>解疑课堂</h3><p>此docker run命令有两个新部分:</p><ul><li><code>--link weather-db</code> -链接名为<code>weather-db</code>的容器。你也可以<a href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports">给链接的容器一个别名</a>在PHP容器中使用，但是我们不需要在这里这样做。</li><li><code>sunmking/weather-app</code> -我们使用的是本章开头构建的新 Docker 镜像，而不是使用<code>php:apache</code>。这样做的原因是我们需要在自定义 Docker 镜像中添加的 PHP MySQLi PDO PDO_MYSQL扩展。</li></ul><p>现在，PHP容器已启动并正在运行，您应该能够导航到位置ID，如下所示:</p><p><code>GET [http://localhost:38000/public/index.php/weather/310000](http://localhost:38000/public/index.php/weather/310000)</code></p><p>第一次加载此URL时，加载可能需要一两秒钟，但是如果刷新页面，可能会更快的看到结果。我的加载时间不到150毫秒! 这要归功于我们通过将结果保存在数据库中。</p><p><a name="bc34bfd3"></a></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>为了从数据库中删除数据，我们将添加第二个路由。添加以后允许用户从数据库中删除添加的数据:</p><pre class="line-numbers language-none"><code class="language-none">/**  * delete  */ public function delete() {     $rid = $this-&gt;request-&gt;param('location_id', '310000');     // 通过 Mysql 查询天气信息     $weather = Db::table('locations')-&gt;where(['id' =&gt; $rid])-&gt;find();     // 如果查询到了     if($weather){         Db::table('locations')-&gt;where(['id' =&gt; $rid])-&gt;delete();         //直接返回         return json("Location {$rid} deleted.",200);     }else{         return json("Location {$rid} Not Found.", 404);     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在您可以使用<a href="https://www.apipost.cn/?utm_source=10041&amp;sg_vid=RudKSyeEAd_RYBj6MfyaszRDo_DR6A_MN06790A6666666Fc4CoR6666666">ApiPost</a>或<a href="https://www.getpostman.com/">postman</a>发送一个<code>delete</code>请求。例如:</p><p><code>DELETE http://localhost:38000/public/index.php/locations/310000</code></p><p>你应该看到一条信息<code>Location 310000</code> 已删除。现在当你做一个<code>GET</code> 再次请求该URL，您将等待更长的时间，因为结果来自 高德天气 API。</p><p>如果一切工作正常，你现在应该能够像以前一样访问该应用程序</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Docker </tag>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker PHP 入门实践(三)</title>
      <link href="/2023/02/24/docker-php-ru-men-shi-jian-san/"/>
      <url>/2023/02/24/docker-php-ru-men-shi-jian-san/</url>
      
        <content type="html"><![CDATA[<p><a name="416c8f90"></a></p><h1 id="第三章。创建一个-ThinkPHP-应用程序"><a href="#第三章。创建一个-ThinkPHP-应用程序" class="headerlink" title="第三章。创建一个 ThinkPHP 应用程序"></a>第三章。创建一个 ThinkPHP 应用程序</h1><p>在本教程的其余部分，我们将基于 ThinkPHP 框架完成一个天气查询的应用。使用 <a href="https://lbs.amap.com/api/webservice/guide/api/weatherinfo/">高德开放平台-天气查询</a> 的接口来实现我们的功能。把查询数据缓存到 MySql 中，这样就不用每次频繁的请求第三方的接口了（有请求次数限制）</p><blockquote><p>选择高德开放平台-天气查询 API 主要是因为它是免费的。当然你也可以使用其他的第三方天气查询接口，看个人喜好。<br>该应用是一个非常简单的 REST API 应用，主要实现两个接口。</p></blockquote><ul><li><code>GET /weather/:location_id</code> - 从数据库中获取天气（如果存在的话），如果不存在，则从 第三方接口获取。</li><li><code>DELETE /weather/:location_id</code> - 从数据库中删除已缓存的天气信息。再次查询该地点的天气时，将从高德的天气接口获取。</li></ul><p><br> 在我们进行应用编码之前，首先使用 Docker 安装并运行 <a href="https://www.kancloud.cn/manual/thinkphp6_0/1037479">ThinkPHP</a></p><p><a name="a1f7f894"></a></p><h2 id="安装-ThinkPHP-Framework"><a href="#安装-ThinkPHP-Framework" class="headerlink" title="安装 ThinkPHP Framework"></a>安装 ThinkPHP Framework</h2><p>ThinkPHP 是一个免费开源的，快速、简单的面向对象的<strong>轻量级PHP开发框架</strong>，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。ThinkPHP从诞生以来一直秉承简洁实用的设计原则，在保持出色的性能和至简代码的同时，更注重易用性。遵循Apache2开源许可协议发布，意味着你可以免费使用ThinkPHP，甚至允许把你基于ThinkPHP开发的应用开源或商业产品发布/销售。<br>这就是为什么我选择它作为本教程的教学框架。我不想让你因为一个框架而放弃，但我也不想从头开始建立所有的东西，因为该教程的重点是Docker，而不是我们的PHP应用。</p><p>用Docker 创建 ThinkPHP 应用实际上比用本地配置PHP环境所需的操作少。并且为我们还需要使用 <a href="https://getcomposer.org/">Composer</a>，多亏了Docker，我们甚至不需要在主机上安装它。</p><p>首先打开你的终端，创建一个项目目录。</p><pre class="line-numbers language-none"><code class="language-none">mkdir docker-app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并进入到该目录中</p><pre class="line-numbers language-none"><code class="language-none">cd docker-app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在使用[官方Composer Docker镜像]（<a href="https://hub.docker.com/_/composer/%EF%BC%89%E5%AE%89%E8%A3%85">https://hub.docker.com/_/composer/）安装</a> ThinkPHP 。</p><pre class="line-numbers language-none"><code class="language-none">docker run --rm --interactive --tty -v E:/workplace/docker-app/:/app composer:latest create-project topthink/think weather-app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你查看<code>weather-app/</code>目录，你会看到 ThinkPHP 6 的项目目录，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">dirE:\workplace\docker-app\weather-app 的目录2022/02/11  16:31    &lt;DIR&gt;          .2022/02/11  16:30    &lt;DIR&gt;          ..2021/12/16  21:06               231 .example.env2021/12/16  21:06                34 .gitignore2021/12/16  21:06             2,038 .travis.yml2021/12/16  21:06    &lt;DIR&gt;          app2021/12/16  21:06             1,094 composer.json2022/02/11  16:31            36,134 composer.lock2021/12/16  21:06    &lt;DIR&gt;          config2021/12/16  21:06    &lt;DIR&gt;          extend2021/12/16  21:06             1,822 LICENSE.txt2021/12/16  21:06    &lt;DIR&gt;          public2021/12/16  21:06             1,459 README.md2021/12/16  21:06    &lt;DIR&gt;          route2021/12/16  21:06    &lt;DIR&gt;          runtime2021/12/16  21:06               180 think2022/02/11  16:31    &lt;DIR&gt;          vendor2021/12/16  21:06    &lt;DIR&gt;          view<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="s39XF"></a></p><h3 id="创建-ThinkPHP-应用的过程中的命令梳理"><a href="#创建-ThinkPHP-应用的过程中的命令梳理" class="headerlink" title="创建 ThinkPHP 应用的过程中的命令梳理"></a>创建 ThinkPHP 应用的过程中的命令梳理</h3><p><br>我们的 docker 运行命令与第二章中的命令相似，但我们使用了不同的镜像。我们没有使用运行hello.php 脚本的 PHP 镜像，而是使用了一个 Composer 镜像。让我们来看看有什么变化。</p><ul><li><code>composer:latest</code> - 这表明我们在这个容器中使用的镜像。如果需要，你可以指定Composer的特定版本；只要查看<a href="https://hub.docker.com/_/composer/">Docker Hub</a>上支持的镜像标签列表。</li><li><code>create-project topthink/think weather-app</code> - 这是实际将 ThinkPHP 6 安装到容器工作目录中的命令。因为该工作目录是我们主机目录的一个卷，所以 composer 安装的文件现在在主机和容器中都存在。在这一点上，你的应用程序实际上没有做任何事情，但 ThinkPHP 6 已经被安装了，我们现在对 composer 在 Docker 中如何与 PHP 一起工作有了一些了解。</li></ul><p><a name="201ee83f"></a></p><h2 id="新建路由与-Controller-（逻辑处理）-文件"><a href="#新建路由与-Controller-（逻辑处理）-文件" class="headerlink" title="新建路由与 Controller （逻辑处理） 文件"></a>新建路由与 Controller （逻辑处理） 文件</h2><p>项目创建完成后，我们需要添加几个路由 URL 和 Controller 文件 。让我们打开  weather-app 目录下的 app/controller , 然后新建 Weather.php 文件，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpnamespace app\controller;use app\BaseController;class Weather extends BaseController{    public function get()    {        // todo        echo "location_id is ".$this-&gt;request-&gt;param('location_id');    }    public function delete()    {        // todo        echo "location_id is ".$this-&gt;request-&gt;param('location_id');    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后打开  weather-app 目录下的 app/route , 在 app.php 文件中追加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">Route::get('/weather/:location_id','weather/get');Route::delete('/weather/:location_id','weather/delete');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a name="4835c33a"></a></p><h2 id="运行我们的应用程序"><a href="#运行我们的应用程序" class="headerlink" title="运行我们的应用程序"></a>运行我们的应用程序</h2><p>现在我们可以在 Docker 容器中运行我们的应用程序，只是为了验证我们的程序是否运行正常，因为我们只添加了两个路由 URL。打开命令行，运行。</p><pre class="line-numbers language-none"><code class="language-none">docker run --privileged=true --rm -p 38000:80 -v E:/workplace/docker-app/:/var/www/html php:apache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，在浏览器中打开 <a href="http://localhost:38000/weather-app/public/index.php/weather/1">http://localhost:38000/weather-app/public/index.php/weather/1</a>，你应该看到一个空页面，上面有以下文字:</p><pre class="line-numbers language-none"><code class="language-none">location_id is 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><br>那么恭喜你，你刚刚已经成功地在 Docker 中运行了你的第一个 ThinkPHP 应用程序。<br><a name="D1y8T"></a></p><h3 id="运行-ThinkPHP-应用的命令梳理"><a href="#运行-ThinkPHP-应用的命令梳理" class="headerlink" title="运行 ThinkPHP 应用的命令梳理"></a>运行 ThinkPHP 应用的命令梳理</h3><p><br>这次我们使用的<code>docker run</code>命令与我们用来运行 hello.php 脚本 和<code>composer create-project ...</code>的两个命令不同。原因是这次我们想获得包含 <a href="https://httpd.apache.org/">Apache</a> 的最新版本的PHP，这样我们就可以为我们的 Web 应用提供服务。让我们更详细地了解新增的命令部分。</p><ul><li><code>-p 38000:80</code> - 这里我们在容器和主机系统之间定义了<a href="https://docs.docker.com/engine/reference/commandline/port/">端口映射</a>。这个命令说Docker应该把容器上的80号端口映射到我们主机上的38000号端口。你可以在你的主机上选择任何有效的端口，但使用一个高的端口（10000以上）可能是一个好主意，因为许多低的端口被保留给大多数标准机器上的内置进程。对于容器，你必须*使用80端口，因为那是Docker镜像暴露的端口，Apache在上面运行。</li><li>–privileged=true         - 容器内是否使用 root 权限</li><li><code>-v E:/workplace/docker-app/:/var/www/html</code> - 这一次，我们将代码从主机挂载到容器的<code>/var/www/html</code>目录。原因是，PHP的Apache镜像是从这个目录中提供代码的。这是我们之前运行的PHP脚本之间的一个微妙但关键的区别。请务必仔细阅读<a href="https://hub.docker.com/_/php/">官方PHP Docker镜像文档</a>以避免遗漏这样的事情。</li><li><code>php:apache</code> - 该镜像是官方的 PHP Apache 容器。它包含PHP和Apache（一种流行的Web服务器）在同一个容器中，允许你快速提供代码用于本地开发。当然你也可以选择是使用<code>php:fpm</code>镜像 链接一个<code>nginx</code>的镜像，这些我不会在本书中介绍，需要你自己去了解。</li><li>最后，你会注意到，这次在镜像名称后面没有命令。这可能会让新的Docker用户感到困惑，但在默认情况下，即使你没有指定命令，大多数镜像也会运行一些命令。在PHP Apache镜像的例子中，默认的命令是运行<a href="https://github.com/docker-library/php/blob/903540ea7918b5cabed6b32e81f8518f9e6f204f/7.1/apache/apache2-foreground">一个shell脚本</a>来启动Apache。这个脚本正是我们想要的，所以没有理由去改变它。<br>在这一点上，你的终端将显示任何进来的Apache请求，所以当你加载第一个URL时，你可能看到类似的东西。</li></ul><pre class="line-numbers language-none"><code class="language-none">172.17.0.1 - - [11/Feb/2022:09:14:02 +0000] "GET /weather-app/public/index.php/weather/1 HTTP/1.1" 200 245 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.43"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以通过向终端发送一个 “中断 “信号来停止和退出终端。在  windows 上，这可以通过按 Ctrl 和按<code>c</code>来实现。</p><p><a name="108dfb93"></a></p><h2 id="更多Docker运行选项"><a href="#更多Docker运行选项" class="headerlink" title="更多Docker运行选项"></a>更多Docker运行选项</h2><p><a name="80835cfc"></a></p><h3 id="在-Detached-模式下运行"><a href="#在-Detached-模式下运行" class="headerlink" title="在 Detached 模式下运行"></a>在 Detached 模式下运行</h3><p>运行你的新网络应用程序的另一个选择是在 “<a href="https://docs.docker.com/engine/reference/run/#detached-vs-foreground">Detached</a>“模式中运行容器。这意味着你在终端将不会看到来自你的容器的输出。这可以通过在我们之前的命令中添加<code>-d</code>标志来实现。</p><pre class="line-numbers language-none"><code class="language-none">docker run --privileged=true -d --rm -p 38000:80 -v E:/workplace/docker-app/:/var/www/html php:apache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a name="Amn8M"></a></p><h3 id="停止一个容器"><a href="#停止一个容器" class="headerlink" title="停止一个容器"></a>停止一个容器</h3><p><br>在分离模式下启动容器后，你的终端将显示新容器的完整ID–类似于<code>a70d25c2a7cedae673f8ab...</code>如果你想停止这个容器，你可以使用<code>docker stop</code>命令，用容器的ID告诉Docker。比如说</p><pre class="line-numbers language-none"><code class="language-none">docker stop a70d25c2a7cedae673f8ab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为输入整个ID是很麻烦的，如果你愿意，Docker允许你只输入前三个或更多的字符。</p><pre class="line-numbers language-none"><code class="language-none">docker stop a70<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a name="23340a84"></a></p><h3 id="命名容器"><a href="#命名容器" class="headerlink" title="命名容器"></a>命名容器</h3><p>最后，我建议<a href="https://docs.docker.com/engine/reference/run/#container-identification">为你的容器命名</a>。我们在本书后面的许多例子中都会这样做，因为用名字来记住一个容器比用随机分配的ID要容易得多，再加上ID是随机的，所以每次你运行一个新版本的容器时，它都会得到一个新的ID。只要不是已经有一个同名的容器，名字就可以多次发出来。为了给我们的新应用容器命名，我们可以用传入的<code>--name</code>标志重新创建它。</p><pre class="line-numbers language-none"><code class="language-none">docker run --privileged=true -d --rm --name=weather-app -p 38000:80 -v E:/workplace/docker-app/:/var/www/html php:apache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用<a href="https://docs.docker.com/engine/reference/run/">docker run</a>命令时，还有许多可用的选项，所以你可能想更详细地阅读文档。在我们开发其余的应用程序时，我们会涉及其中的一些选项。<br><a name="AHlDJ"></a></p><h2 id="添加高德天气-SDK"><a href="#添加高德天气-SDK" class="headerlink" title="添加高德天气 SDK"></a><br>添加高德天气 SDK</h2><p><br>现在我们要引入高德的天气 SDK ，在使用该 SDK 之前你需要阅读<a href="https://lbs.amap.com/api/webservice/guide/api/weatherinfo/">高德开放平台-天气查询</a>的技术文档，再添加 SDK 之前我们首先要确保所有现有的容器都停止了。</p><pre class="line-numbers language-none"><code class="language-none">$ docker ps   //之后在运行 上面的命令停止容器docker stop 容器ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个命令将<a href="https://docs.docker.com/engine/reference/commandline/ps/">列出所有正在运行的容器</a>。你也可以通过添加<code>-a</code>标志来查看停止的容器。<br>如果有任何容器正在运行，那么在我们继续前进之前，使用<code>docker stop &lt;ID&gt;</code>来停止它们。</p><p><a name="zjJ98"></a></p><h3 id="添天气-SDK"><a href="#添天气-SDK" class="headerlink" title="添天气 SDK"></a>添天气 SDK</h3><p><br>执行命令添加<a href="https://github.com/clyde-cn/php-amap-weather">高德天气 SDK</a>，欢迎点赞+星。这是作者之前封装的SDK，当然你也可以自己重新封装或者用其他的天气 SDK，现在在你的终端运行：</p><pre class="line-numbers language-none"><code class="language-none">docker run --rm --interactive --tty -v E:/workplace/docker-app/weather-app:/app composer:latest require clydecn/php-amap-weather<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令将在你的项目中装新的软件包。在这个过程中，你应该在终端看到一些类似这样的输出。</p><pre class="line-numbers language-none"><code class="language-none">Using version ^1.0 for clydecn/php-amap-weather./composer.json has been updatedRunning composer update clydecn/php-amap-weatherLoading composer repositories with package informationUpdating dependenciesLock file operations: 7 installs, 0 updates, 0 removals  - Locking clydecn/php-amap-weather (v1.0.0)  - Locking guzzlehttp/guzzle (6.5.5)  - Locking guzzlehttp/promises (1.5.1)  - Locking guzzlehttp/psr7 (1.8.3)  - Locking ralouphie/getallheaders (3.0.3)  - Locking symfony/polyfill-intl-idn (v1.24.0)  - Locking symfony/polyfill-intl-normalizer (v1.24.0)Writing lock fileInstalling dependencies from lock file (including require-dev)Package operations: 7 installs, 0 updates, 0 removals  - Downloading symfony/polyfill-intl-normalizer (v1.24.0)  - Downloading symfony/polyfill-intl-idn (v1.24.0)  - Downloading ralouphie/getallheaders (3.0.3)  - Downloading guzzlehttp/psr7 (1.8.3)  - Downloading guzzlehttp/promises (1.5.1)  - Downloading guzzlehttp/guzzle (6.5.5)  - Downloading clydecn/php-amap-weather (v1.0.0) 0/7 [&gt;---------------------------]   0%  - Downloading symfony/polyfill-intl-idn (v1.24.0)  - Downloading ralouphie/getallheaders (3.0.3)  - Downloading guzzlehttp/psr7 (1.8.3)  - Downloading clydecn/php-amap-weather (v1.0.0)  - Downloading symfony/polyfill-intl-normalizer (v1.24.0)  - Downloading guzzlehttp/promises (1.5.1)  - Downloading guzzlehttp/guzzle (6.5.5)  - Installing symfony/polyfill-intl-normalizer (v1.24.0): Extracting archive  - Installing symfony/polyfill-intl-idn (v1.24.0): Extracting archive  - Installing ralouphie/getallheaders (3.0.3): Extracting archive  - Installing guzzlehttp/psr7 (1.8.3): Extracting archive  - Installing guzzlehttp/promises (1.5.1): Extracting archive  - Installing guzzlehttp/guzzle (6.5.5): Extracting archive  - Installing clydecn/php-amap-weather (v1.0.0): Extracting archive3 package suggestions were added by new dependencies, use `composer suggest` to see details.Generating autoload files&gt; @php think service:discoverSucceed!&gt; @php think vendor:publishFile /app/config/trace.php exist!Succeed!10 packages you are using are looking for funding.Use the `composer fund` command to find out more!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在 SDK 已经安装完毕，可以使用了。<br><a name="Ogbcg"></a></p><h2 id="调用-SDK-API"><a href="#调用-SDK-API" class="headerlink" title="调用 SDK API"></a><br>调用 SDK API</h2><p><br>我们将使用刚刚添加的高德天气 SDK 来完善我们的业务逻辑，打开 controller 目录下的 Weather.php 添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?phpnamespace app\controller;use app\BaseController;use Clydecn\Amap\Weather as AmapWeather;class Weather extends BaseController{    public $key;    public $weather;     // 初始化     protected function initialize()     {         $this-&gt;key = "KEY"; // 高德 KEY         $this-&gt;weather = new AmapWeather($this-&gt;key);     }     public function get()    {         $rid = $this-&gt;request-&gt;param('location_id','310000');        // 查询当天天气        $res = $this-&gt;weather-&gt;getLiveWeather($rid);        return json($res,200);    }    public function delete()    {        // todo        echo "location_id is ".$this-&gt;request-&gt;param('location_id');    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="CozUq"></a></p><h3 id="解疑"><a href="#解疑" class="headerlink" title="解疑"></a>解疑</h3><p><br>我们做了一些更新–主要是对引入天气 API  初始化天气类</p><ul><li><code>$this-&gt;weather=new AmapWeather($this-&gt;key);</code> -  实例化天气API 类</li><li><code>$res=$this-&gt;weather-&gt;getLiveWeather('310000');</code> - 获取天气信息。</li><li><code>return json($res,200);</code> - 最后，返回 Json 数据<br><a name="WZj5v"></a></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a><br>测试</h3><p><br>我们的应用程序已经初步完成了向API传递一个真实的位置ID并返回一些数据。首先，使用这个<a href="https://lbs.amap.com/api/webservice/download">高德位置查询</a>找到一个位置ID。我使用的是上海的ID进行测试。<code>310000</code>，当然你直接传 上海 也是可以的。ok，让我们再次运行Docker容器。</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --privileged=true --rm --name=weather-app -p 38000:80 -v E:/workplace/docker-app/:/var/www/html php:apache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并在你的浏览器中访问正在运行的应用程序，地址是<a href="http://localhost:38000/weather-app/public/index.php/weather/310000">http://localhost:38000/weather-app/public/index.php/weather/310000</a>。你应该可以看到一个JSON数据，看起来像这样。</p><pre class="line-numbers language-none"><code class="language-none">{"status":"1","count":"1","info":"OK","infocode":"10000","lives":[{"province":"上海","city":"上海市","adcode":"310000","weather":"晴","temperature":"11","winddirection":"东","windpower":"≤3","humidity":"38","reporttime":"2022-02-14 14:01:45"}]}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你的 Docker 化的 PHP 应用程序现在正从外部数据源返回真实数据，并在Apache中提供服务，但你可能会注意到，它的速度并不快（我的页面加载时间为1.92秒！）。<br>高德天气 API 是一个免费的服务，其他国家可能无法访问。为了解决这个问题，我们将把查询的数据保存在我们自己的 MySQL 数据库中，可以再下次访问的时候可以快速地响应。这将极大地提高性能，下个章节我们将学习如何用 Docker 将 MySql 与 PHP 应用程序相结合。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Docker </tag>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker PHP 入门实践(二)</title>
      <link href="/2023/02/24/docker-php-ru-men-shi-jian-er/"/>
      <url>/2023/02/24/docker-php-ru-men-shi-jian-er/</url>
      
        <content type="html"><![CDATA[<p><a name="ShQnI"></a></p><h1 id="第二章-在-Docker-中运行-PHP-脚本"><a href="#第二章-在-Docker-中运行-PHP-脚本" class="headerlink" title="第二章 .  在 Docker 中运行 PHP 脚本"></a>第二章 .  在 Docker 中运行 PHP 脚本</h1><p>在我们开始构建应用程序之前，先了解一下如何在Docker中运行一个PHP脚本。我们从编写一个经典的Hello World开始<br>PHP脚本如下:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Hello World!"</span><span class="token punctuation">;</span> </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以在虚拟机或者笔记本的终端上运行这个脚本(假设你已经安装了PHP)。你应该可以看到终端输出 Hello World !<br><a name="THr0o"></a></p><h2 id="Docker-镜像介绍"><a href="#Docker-镜像介绍" class="headerlink" title="Docker 镜像介绍"></a>Docker 镜像介绍</h2><p>Docker 在一个容器中运行每个进程。所有这些容器都在主机上运行，这是你在这本书里的电脑。一旦应用程序准备好进入生产环境，服务器(或多个服务器)将充当 Docker 主机。<br>每个运行的容器后面都有一个“镜像”。Docker 镜像是由软件开发人员使用 dockerfile 创建和维护的。换句话说，如果您想从头创建自己的 Docker 镜像，那么首先要创建一个新的Dockerfile，然后“构建”一个镜像，然后在容器中 “运行” 该镜像。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/267928/1633934836324-d3dda23c-25e9-422e-b638-6362b9ec5069.png#clientId=u3aeacf32-7c17-4&amp;from=ui&amp;id=u5adf1e16&amp;name=diagram2.png&amp;originHeight=512&amp;originWidth=1185&amp;originalType=binary&amp;ratio=1&amp;size=59486&amp;status=done&amp;style=none&amp;taskId=ud0304b0f-dc0d-4a28-8c29-ed176185a2d" alt="diagram2.png"><br>通常我们不需要从头构建镜像。大多数流行的软件(包括PHP)都有由软件开发人员或感兴趣的社区维护的镜像。在这没必要构建一个全新的镜像，但是稍后我们将会讲解到如何通过编写自己的 Dockerfile 来扩展现有镜像。<br>Docker 镜像可以构建并存储在主机上，也可以保存在远程 “registry” 中。除了维护核心的Docker 平台之外，Docker 团队还维护一个名为 <a href="https://hub.docker.com/">Docker Hub</a> 镜像管理平台，在这里可以免费存储公共镜像。大多数开源软件团队在 Docker Hub 上托管官方镜像，包括 <a href="https://hub.docker.com/_/php/">PHP</a>。<br><a name="bVQTL"></a></p><h2 id="获取PHP-Docker-镜像"><a href="#获取PHP-Docker-镜像" class="headerlink" title="获取PHP Docker 镜像"></a>获取PHP Docker 镜像</h2><p>为了在容器中运行 hello.php 脚本，首先需要为 pull 一个 PHP 镜像，选择 PHP 的最新稳定版本。在终端中执行:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull php:latest <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在你的终端应该可以看到类似这样的东西:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">latest: Pulling from library/php7d63c13d9b9b: Pull complete24b15dfd3cfa: Pull complete64625c2e355f: Pull complete275a8dd8f358: Pull complete25140c092894: Pull complete48e615a81d63: Pull complete5b1d56720240: Pull complete16d610fad528: Pull complete68ac649f8fe5: Pull complete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表示 Docker 正在拉取 PHP 最新版镜像。当拉取完成时，在终端会显示一个如下的状态，表明它已经获取了最新的版本:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Digest: sha256:16573d7e56efa328e59066205870e66c0ad851491df9d0ee66c05bbe4961f8edStatus: Downloaded newer image <span class="token keyword">for</span> php:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意:“latest”标记是大多数 Docker 映像用于其软件的最新版本的标准约定。不要不加区分地使用“latest”，因为它会自动检索到“latest”版本，即使有重大的版本更改。<br>因为 hello.php 脚本很简单，所以我们使用哪个版本的PHP并不重要，但是如果我们需要为一个现有项目运行一个旧版本的PHP呢? 这是 Docker 真正的亮点，因为我们只需要在运行Docker pull时指定PHP版本。例如，下载PHP 5.6镜像，只需运行如下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull php:5.6 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以使用这个方法来获得最新的、未发布的PHP版本(假设 <a href="https://hub.docker.com/_/php/">PHP registry’s list</a> 中至少有一个Beta 版本)。这对于需要经常使用多个 PHP 版本的开发人员非常有帮助。<br><a name="y5h5M"></a></p><h2 id="将代码放入容器中"><a href="#将代码放入容器中" class="headerlink" title="将代码放入容器中"></a>将代码放入容器中</h2><p>为了更好的往下进行，您必须稍微了解 Docker 如何访问主机系统上的文件。一个正在运行的容器不能直接读取或写入文件到您的计算机—容器本质上它是独立的系统。相反，我们要运行的容器数据来自于主机中挂载的 <a href="https://docs.docker.com/engine/admin/volumes/volumes/">volume</a> 或者在构建镜像时添加代码。<br>在本书的后面，我们将介绍如何用 Dockerfiles 构建 Docker 映像并以这种方式添加代码，但是对于这个简单的 Hello World! 示例，我们将 hello.php 的目录文件挂载到我们需要运行的PHP容器中。<br><a name="EIIMG"></a></p><h2 id="在Docker中运行Hello-World脚本"><a href="#在Docker中运行Hello-World脚本" class="headerlink" title="在Docker中运行Hello World脚本"></a>在Docker中运行Hello World脚本</h2><p>现在我们已经从Docker Hub中获取了一些PHP镜像，并且对Docker如何使用卷有了一些了解，我们可以在终端的容器中运行我们的脚本:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-v</span> <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/app php:latest php /app/hello.php <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果一切正确，应该可以看到输出Hello World!。恭喜你在Docker中运行了第一个PHP脚本!</p><p><a name="nDp80"></a></p><h3 id="它是如何运行的"><a href="#它是如何运行的" class="headerlink" title="它是如何运行的?"></a>它是如何运行的?</h3><p>让我们回顾一下Docker命令以及它的含义:</p><ul><li>docker run - 这是Docker的命令 <a href="https://docs.docker.com/engine/reference/run/">在新容器中运行命令</a>.有很多选项可供您输入，但我们将从基础知识开始。</li><li>–rm - 这告诉Docker在命令运行后“删除”容器。 或者，您可以保存容器以再次运行它，但如果您最终没有删除容器，它会占用空间，因此在大多数情况下最好设置删除选项。</li><li>-v $(pwd):/app - 这是Docker的命令 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">mount a volume</a>. 通常，您将路径传递到主机系统、冒号、以及容器中文件夹的路径上。 卷是一个强大的工具，但是对于这个简单的示例，我们只是将当前目录(使用$(pwd))从终端挂载到新的 Docker 容器中的 /app 目录中。</li><li>php:latest - 这表示我们为这个容器使用的镜像。您也可以指定其他的PHP镜像(例如:PHP:7.0或PHP:5.6)来使用该语言的特定版本。</li><li>php /app/hello.php - 最后，这是 Docker 将在容器中运行的命令。由于我们将代码挂载在容器的/app目录中，因此必须从该目录运行脚本。</li></ul><p>现在您已经对 Docker 有了基本的了解，并且可以在容器中运行 PHP 脚本，现在是时候构建一些更有用、更有趣的东西了。可以简单的休息一下，并阅读一些关于 Docker 的资料(<a href="https://doc/">https://doc</a>,docker.com/) ，当您准备好之后，请继续阅读本文，开始在 Docker 中构建 PHP web 应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Docker </tag>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker PHP 入门实践(一)</title>
      <link href="/2023/02/24/docker-php-ru-men-shi-jian-yi/"/>
      <url>/2023/02/24/docker-php-ru-men-shi-jian-yi/</url>
      
        <content type="html"><![CDATA[<p><a name="ShQnI"></a></p><h1 id="第一章-Docker-的介绍"><a href="#第一章-Docker-的介绍" class="headerlink" title="第一章 .  Docker 的介绍"></a>第一章 .  Docker 的介绍</h1><p>Docker已迅速成为首选的容器引擎，并且它正在快速的占领市场。该系列的教程将一步一步引导你使用Docker构建一个PHP Web应用程序，同时也会在其中穿插解释一些Docker&amp;PHP的基础知识。</p><p>在该系列的教程中，会包括以下知识点：</p><ul><li>使用Composer安装依赖项.</li><li>使用Docker构建PHP环境.</li><li>将数据保存到MySQL数据库.</li><li>Thinkphp6 框架的使用</li><li>如何对接第三方API</li><li>……</li><li><br></li></ul><p>读这本书需要有一定PHP开发经验；知道如何打开计算机的终端，并从中运行PHP脚本；并且抽出一上午或一下午的时间来上手实践。最重要的是你要安装<a href="https://www.docker.com/community-edition">docker</a>。</p><p><a name="q68K1"></a></p><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么?"></a>Docker 是什么?</h2><p>Docker是一个管理和运行容器的平台。容器类似于<a href="https://en.wikipedia.org/wiki/Virtual_machine">虚拟机</a>，但它们实际上并不模拟整个操作系统。相反，您运行的所有容器与主机共享相同的底层内核，这意味着它们比虚拟机轻得多。因此，容器非常高效，并且大多数实际应用程序同时运行多个容器。Docker帮助您使用容器的<a href="https://docs.docker.com/engine/userguide/networking/">networks</a>将这些容器链接在一起，并帮助您使用<a href="https://docs.docker.com/compose/">Docker Compose</a>配置文件定义容器。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/267928/1633934410244-c4a6edce-214e-4abe-9ce3-4d27408da13d.png#height=720&amp;id=ufa27276f&amp;name=diagram1.png&amp;originHeight=720&amp;originWidth=960&amp;originalType=binary&amp;ratio=1&amp;size=78194&amp;status=done&amp;style=none&amp;width=960" alt="diagram1.png"><br><a name="K7b21"></a></p><h2 id="为什么使用-Docker"><a href="#为什么使用-Docker" class="headerlink" title="为什么使用 Docker?"></a>为什么使用 Docker?</h2><p>企业使用一项技术是为了解决当前企业环境中存在的某个痛点。目前整个软件行业存在着以下几个痛点。<br>（1）软件更新发布及部署低效，过程烦琐且需要人工介入。<br>（2）环境一致性难以保证。<br>（3）不同环境之间迁移成本太高。<br>Docker 在很大程度上解决了上述问题：<br>首先，Docker 的使用十分简单，从开发的角度来看就是“三步走”：构建、运输、运行。其中，关键步骤是构建环节，即打包镜像文件。但是从测试和运维的角度来看，那就只有两步：复制、运行。有了这个镜像文件，想复制到哪里运行都可以，完全和平台无关。<br>Docker 这种容器技术隔离出了独立的运行空间，不会和其他应用争用系统资源，不需要考虑应用之间的相互影响。<br>其次，因为在构建镜像时就处理完了服务程序对于系统的所有依赖，所以在使用时，可以忽略原本程序的依赖以及开发语言。对测试和运维人员而言，可以更专注于自己的业务内容。<br>最后，Docker 为开发者提供了一种开发环境的管理办法，帮助测试人员保证环境的同步，为运维人员提供了可移植的标准化部署流程。</p><p><a name="8cc76ce1"></a></p><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>Nickname: clyde-cn ( saviorlv )<br>Skill: PHP Python Golang Vue<br>Email: <a href="mailto:1042080686@qq.com">1042080686@qq.com</a><br>Desc: 90后 IT 民工</p><p><a name="d7945270"></a></p><h2 id="关于许可证"><a href="#关于许可证" class="headerlink" title="关于许可证"></a>关于许可证</h2><p>© 2020-09-27, 拯救伏地魔（saviorlv）</p><p>版权所有。未经版权所有者的书面许可，不得以任何形式或通过任何电子或机械方式复制本教程的任何部分。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Docker </tag>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
